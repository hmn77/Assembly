
AVRASM ver. 2.2.6  C:\Users\Hooman\Documents\Atmel Studio\7.0\squer wave_keypad\squer wave_keypad\main.asm Mon Apr 27 11:25:41 2020

[builtin](2): Including file 'E:/Atmel Studio\7.0\Packs\atmel\ATmega_DFP\1.2.132\avrasm\inc\m32def.inc'
C:\Users\Hooman\Documents\Atmel Studio\7.0\squer wave_keypad\squer wave_keypad\main.asm(32): Including file 'E:/Atmel Studio\7.0\Packs\atmel\ATmega_DFP\1.2.132\avrasm\inc\M32DEF.INC'
[builtin](2): Including file 'E:/Atmel Studio\7.0\Packs\atmel\ATmega_DFP\1.2.132\avrasm\inc\m32def.inc'
C:\Users\Hooman\Documents\Atmel Studio\7.0\squer wave_keypad\squer wave_keypad\main.asm(32): Including file 'E:/Atmel Studio\7.0\Packs\atmel\ATmega_DFP\1.2.132\avrasm\inc\M32DEF.INC'
                                 
                                 ;
                                 
                                 ;***** Created: 2011-02-09 12:03 ******* Source: ATmega32.xml ************
                                 ;*************************************************************************
                                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                                 ;* 
                                 ;* Number            : AVR000
                                 ;* File Name         : "m32def.inc"
                                 ;* Title             : Register/Bit Definitions for the ATmega32
                                 ;* Date              : 2011-02-09
                                 ;* Version           : 2.35
                                 ;* Support E-mail    : avr@atmel.com
                                 ;* Target MCU        : ATmega32
                                 ;* 
                                 ;* DESCRIPTION
                                 ;* When including this file in the assembly program file, all I/O register 
                                 ;* names and I/O register bit names appearing in the data book can be used.
                                 ;* In addition, the six registers forming the three data pointers X, Y and 
                                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                                 ;* SRAM is also defined 
                                 ;* 
                                 ;* The Register names are represented by their hexadecimal address.
                                 ;* 
                                 ;* The Register Bit names are represented by their bit number (0-7).
                                 ;* 
                                 ;* Please observe the difference in using the bit names with instructions
                                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                                 ;* (skip if bit in register set/cleared). The following example illustrates
                                 ;* this:
                                 ;* 
                                 ;* in    r16,PORTB             ;read PORTB latch
                                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                                 ;* out   PORTB,r16             ;output to PORTB
                                 ;* 
                                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                                 ;* rjmp  TOV0_is_set           ;jump if set
                                 ;* ...                         ;otherwise do something else
                                 ;*************************************************************************
                                 
                                 #ifndef _M32DEF_INC_
                                 #define _M32DEF_INC_
                                 
                                 
                                 #pragma partinc 0
                                 
                                 ; ***** SPECIFY DEVICE ***************************************************
                                 .device ATmega32
                                 #pragma AVRPART ADMIN PART_NAME ATmega32
                                 .equ	SIGNATURE_000	= 0x1e
                                 .equ	SIGNATURE_001	= 0x95
                                 .equ	SIGNATURE_002	= 0x02
                                 
                                 #pragma AVRPART CORE CORE_VERSION V2E
                                 
                                 
                                 ; ***** I/O REGISTER DEFINITIONS *****************************************
                                 ; NOTE:
                                 ; Definitions marked "MEMORY MAPPED"are extended I/O ports
                                 ; and cannot be used with IN/OUT instructions
                                 .equ	SREG	= 0x3f
                                 .equ	SPL	= 0x3d
                                 .equ	SPH	= 0x3e
                                 .equ	OCR0	= 0x3c
                                 .equ	GICR	= 0x3b
                                 .equ	GIFR	= 0x3a
                                 .equ	TIMSK	= 0x39
                                 .equ	TIFR	= 0x38
                                 .equ	SPMCR	= 0x37
                                 .equ	TWCR	= 0x36
                                 .equ	MCUCR	= 0x35
                                 .equ	MCUCSR	= 0x34
                                 .equ	TCCR0	= 0x33
                                 .equ	TCNT0	= 0x32
                                 .equ	OSCCAL	= 0x31
                                 .equ	OCDR	= 0x31
                                 .equ	SFIOR	= 0x30
                                 .equ	TCCR1A	= 0x2f
                                 .equ	TCCR1B	= 0x2e
                                 .equ	TCNT1L	= 0x2c
                                 .equ	TCNT1H	= 0x2d
                                 .equ	OCR1AL	= 0x2a
                                 .equ	OCR1AH	= 0x2b
                                 .equ	OCR1BL	= 0x28
                                 .equ	OCR1BH	= 0x29
                                 .equ	ICR1L	= 0x26
                                 .equ	ICR1H	= 0x27
                                 .equ	TCCR2	= 0x25
                                 .equ	TCNT2	= 0x24
                                 .equ	OCR2	= 0x23
                                 .equ	ASSR	= 0x22
                                 .equ	WDTCR	= 0x21
                                 .equ	UBRRH	= 0x20
                                 .equ	UCSRC	= 0x20
                                 .equ	EEARL	= 0x1e
                                 .equ	EEARH	= 0x1f
                                 .equ	EEDR	= 0x1d
                                 .equ	EECR	= 0x1c
                                 .equ	PORTA	= 0x1b
                                 .equ	DDRA	= 0x1a
                                 .equ	PINA	= 0x19
                                 .equ	PORTB	= 0x18
                                 .equ	DDRB	= 0x17
                                 .equ	PINB	= 0x16
                                 .equ	PORTC	= 0x15
                                 .equ	DDRC	= 0x14
                                 .equ	PINC	= 0x13
                                 .equ	PORTD	= 0x12
                                 .equ	DDRD	= 0x11
                                 .equ	PIND	= 0x10
                                 .equ	SPDR	= 0x0f
                                 .equ	SPSR	= 0x0e
                                 .equ	SPCR	= 0x0d
                                 .equ	UDR	= 0x0c
                                 .equ	UCSRA	= 0x0b
                                 .equ	UCSRB	= 0x0a
                                 .equ	UBRRL	= 0x09
                                 .equ	ACSR	= 0x08
                                 .equ	ADMUX	= 0x07
                                 .equ	ADCSRA	= 0x06
                                 .equ	ADCH	= 0x05
                                 .equ	ADCL	= 0x04
                                 .equ	TWDR	= 0x03
                                 .equ	TWAR	= 0x02
                                 .equ	TWSR	= 0x01
                                 .equ	TWBR	= 0x00
                                 
                                 
                                 ; ***** BIT DEFINITIONS **************************************************
                                 
                                 ; ***** EEPROM ***********************
                                 ; EEDR - EEPROM Data Register
                                 .equ	EEDR0	= 0	; EEPROM Data Register bit 0
                                 .equ	EEDR1	= 1	; EEPROM Data Register bit 1
                                 .equ	EEDR2	= 2	; EEPROM Data Register bit 2
                                 .equ	EEDR3	= 3	; EEPROM Data Register bit 3
                                 .equ	EEDR4	= 4	; EEPROM Data Register bit 4
                                 .equ	EEDR5	= 5	; EEPROM Data Register bit 5
                                 .equ	EEDR6	= 6	; EEPROM Data Register bit 6
                                 .equ	EEDR7	= 7	; EEPROM Data Register bit 7
                                 
                                 ; EECR - EEPROM Control Register
                                 .equ	EERE	= 0	; EEPROM Read Enable
                                 .equ	EEWE	= 1	; EEPROM Write Enable
                                 .equ	EEMWE	= 2	; EEPROM Master Write Enable
                                 .equ	EERIE	= 3	; EEPROM Ready Interrupt Enable
                                 
                                 
                                 ; ***** WATCHDOG *********************
                                 ; WDTCR - Watchdog Timer Control Register
                                 .equ	WDP0	= 0	; Watch Dog Timer Prescaler bit 0
                                 .equ	WDP1	= 1	; Watch Dog Timer Prescaler bit 1
                                 .equ	WDP2	= 2	; Watch Dog Timer Prescaler bit 2
                                 .equ	WDE	= 3	; Watch Dog Enable
                                 .equ	WDTOE	= 4	; RW
                                 .equ	WDDE	= WDTOE	; For compatibility
                                 
                                 
                                 ; ***** EXTERNAL_INTERRUPT ***********
                                 ; GICR - General Interrupt Control Register
                                 .equ	GIMSK	= GICR	; For compatibility
                                 .equ	IVCE	= 0	; Interrupt Vector Change Enable
                                 .equ	IVSEL	= 1	; Interrupt Vector Select
                                 .equ	INT2	= 5	; External Interrupt Request 2 Enable
                                 .equ	INT0	= 6	; External Interrupt Request 0 Enable
                                 .equ	INT1	= 7	; External Interrupt Request 1 Enable
                                 
                                 ; GIFR - General Interrupt Flag Register
                                 .equ	INTF2	= 5	; External Interrupt Flag 2
                                 .equ	INTF0	= 6	; External Interrupt Flag 0
                                 .equ	INTF1	= 7	; External Interrupt Flag 1
                                 
                                 ; MCUCR - General Interrupt Control Register
                                 .equ	ISC00	= 0	; Interrupt Sense Control 0 Bit 0
                                 .equ	ISC01	= 1	; Interrupt Sense Control 0 Bit 1
                                 .equ	ISC10	= 2	; Interrupt Sense Control 1 Bit 0
                                 .equ	ISC11	= 3	; Interrupt Sense Control 1 Bit 1
                                 
                                 ; MCUCSR - MCU Control And Status Register
                                 .equ	ISC2	= 6	; Interrupt Sense Control 2
                                 
                                 
                                 ; ***** TIMER_COUNTER_0 **************
                                 ; TCCR0 - Timer/Counter Control Register
                                 .equ	CS00	= 0	; Clock Select 1
                                 .equ	CS01	= 1	; Clock Select 1
                                 .equ	CS02	= 2	; Clock Select 2
                                 .equ	WGM01	= 3	; Waveform Generation Mode 1
                                 .equ	CTC0	= WGM01	; For compatibility
                                 .equ	COM00	= 4	; Compare match Output Mode 0
                                 .equ	COM01	= 5	; Compare Match Output Mode 1
                                 .equ	WGM00	= 6	; Waveform Generation Mode
                                 .equ	PWM0	= WGM00	; For compatibility
                                 .equ	FOC0	= 7	; Force Output Compare
                                 
                                 ; TCNT0 - Timer/Counter Register
                                 .equ	TCNT0_0	= 0	; 
                                 .equ	TCNT0_1	= 1	; 
                                 .equ	TCNT0_2	= 2	; 
                                 .equ	TCNT0_3	= 3	; 
                                 .equ	TCNT0_4	= 4	; 
                                 .equ	TCNT0_5	= 5	; 
                                 .equ	TCNT0_6	= 6	; 
                                 .equ	TCNT0_7	= 7	; 
                                 
                                 ; OCR0 - Output Compare Register
                                 .equ	OCR0_0	= 0	; 
                                 .equ	OCR0_1	= 1	; 
                                 .equ	OCR0_2	= 2	; 
                                 .equ	OCR0_3	= 3	; 
                                 .equ	OCR0_4	= 4	; 
                                 .equ	OCR0_5	= 5	; 
                                 .equ	OCR0_6	= 6	; 
                                 .equ	OCR0_7	= 7	; 
                                 
                                 ; TIMSK - Timer/Counter Interrupt Mask Register
                                 .equ	TOIE0	= 0	; Timer/Counter0 Overflow Interrupt Enable
                                 .equ	OCIE0	= 1	; Timer/Counter0 Output Compare Match Interrupt register
                                 
                                 ; TIFR - Timer/Counter Interrupt Flag register
                                 .equ	TOV0	= 0	; Timer/Counter0 Overflow Flag
                                 .equ	OCF0	= 1	; Output Compare Flag 0
                                 
                                 
                                 ; ***** TIMER_COUNTER_2 **************
                                 ; TIMSK - Timer/Counter Interrupt Mask register
                                 .equ	TOIE2	= 6	; Timer/Counter2 Overflow Interrupt Enable
                                 .equ	OCIE2	= 7	; Timer/Counter2 Output Compare Match Interrupt Enable
                                 
                                 ; TIFR - Timer/Counter Interrupt Flag Register
                                 .equ	TOV2	= 6	; Timer/Counter2 Overflow Flag
                                 .equ	OCF2	= 7	; Output Compare Flag 2
                                 
                                 ; TCCR2 - Timer/Counter2 Control Register
                                 .equ	CS20	= 0	; Clock Select bit 0
                                 .equ	CS21	= 1	; Clock Select bit 1
                                 .equ	CS22	= 2	; Clock Select bit 2
                                 .equ	WGM21	= 3	; Clear Timer/Counter2 on Compare Match
                                 .equ	CTC2	= WGM21	; For compatibility
                                 .equ	COM20	= 4	; Compare Output Mode bit 0
                                 .equ	COM21	= 5	; Compare Output Mode bit 1
                                 .equ	WGM20	= 6	; Pulse Width Modulator Enable
                                 .equ	PWM2	= WGM20	; For compatibility
                                 .equ	FOC2	= 7	; Force Output Compare
                                 
                                 ; TCNT2 - Timer/Counter2
                                 .equ	TCNT2_0	= 0	; Timer/Counter 2 bit 0
                                 .equ	TCNT2_1	= 1	; Timer/Counter 2 bit 1
                                 .equ	TCNT2_2	= 2	; Timer/Counter 2 bit 2
                                 .equ	TCNT2_3	= 3	; Timer/Counter 2 bit 3
                                 .equ	TCNT2_4	= 4	; Timer/Counter 2 bit 4
                                 .equ	TCNT2_5	= 5	; Timer/Counter 2 bit 5
                                 .equ	TCNT2_6	= 6	; Timer/Counter 2 bit 6
                                 .equ	TCNT2_7	= 7	; Timer/Counter 2 bit 7
                                 
                                 ; OCR2 - Timer/Counter2 Output Compare Register
                                 .equ	OCR2_0	= 0	; Timer/Counter2 Output Compare Register Bit 0
                                 .equ	OCR2_1	= 1	; Timer/Counter2 Output Compare Register Bit 1
                                 .equ	OCR2_2	= 2	; Timer/Counter2 Output Compare Register Bit 2
                                 .equ	OCR2_3	= 3	; Timer/Counter2 Output Compare Register Bit 3
                                 .equ	OCR2_4	= 4	; Timer/Counter2 Output Compare Register Bit 4
                                 .equ	OCR2_5	= 5	; Timer/Counter2 Output Compare Register Bit 5
                                 .equ	OCR2_6	= 6	; Timer/Counter2 Output Compare Register Bit 6
                                 .equ	OCR2_7	= 7	; Timer/Counter2 Output Compare Register Bit 7
                                 
                                 ; ASSR - Asynchronous Status Register
                                 .equ	TCR2UB	= 0	; Timer/counter Control Register2 Update Busy
                                 .equ	OCR2UB	= 1	; Output Compare Register2 Update Busy
                                 .equ	TCN2UB	= 2	; Timer/Counter2 Update Busy
                                 .equ	AS2	= 3	; Asynchronous Timer/counter2
                                 
                                 
                                 ; ***** TIMER_COUNTER_1 **************
                                 ; TIMSK - Timer/Counter Interrupt Mask Register
                                 .equ	TOIE1	= 2	; Timer/Counter1 Overflow Interrupt Enable
                                 .equ	OCIE1B	= 3	; Timer/Counter1 Output CompareB Match Interrupt Enable
                                 .equ	OCIE1A	= 4	; Timer/Counter1 Output CompareA Match Interrupt Enable
                                 .equ	TICIE1	= 5	; Timer/Counter1 Input Capture Interrupt Enable
                                 
                                 ; TIFR - Timer/Counter Interrupt Flag register
                                 .equ	TOV1	= 2	; Timer/Counter1 Overflow Flag
                                 .equ	OCF1B	= 3	; Output Compare Flag 1B
                                 .equ	OCF1A	= 4	; Output Compare Flag 1A
                                 .equ	ICF1	= 5	; Input Capture Flag 1
                                 
                                 ; TCCR1A - Timer/Counter1 Control Register A
                                 .equ	WGM10	= 0	; Waveform Generation Mode
                                 .equ	PWM10	= WGM10	; For compatibility
                                 .equ	WGM11	= 1	; Waveform Generation Mode
                                 .equ	PWM11	= WGM11	; For compatibility
                                 .equ	FOC1B	= 2	; Force Output Compare 1B
                                 .equ	FOC1A	= 3	; Force Output Compare 1A
                                 .equ	COM1B0	= 4	; Compare Output Mode 1B, bit 0
                                 .equ	COM1B1	= 5	; Compare Output Mode 1B, bit 1
                                 .equ	COM1A0	= 6	; Compare Ouput Mode 1A, bit 0
                                 .equ	COM1A1	= 7	; Compare Output Mode 1A, bit 1
                                 
                                 ; TCCR1B - Timer/Counter1 Control Register B
                                 .equ	CS10	= 0	; Prescaler source of Timer/Counter 1
                                 .equ	CS11	= 1	; Prescaler source of Timer/Counter 1
                                 .equ	CS12	= 2	; Prescaler source of Timer/Counter 1
                                 .equ	WGM12	= 3	; Waveform Generation Mode
                                 .equ	CTC10	= WGM12	; For compatibility
                                 .equ	CTC1	= WGM12	; For compatibility
                                 .equ	WGM13	= 4	; Waveform Generation Mode
                                 .equ	CTC11	= WGM13	; For compatibility
                                 .equ	ICES1	= 6	; Input Capture 1 Edge Select
                                 .equ	ICNC1	= 7	; Input Capture 1 Noise Canceler
                                 
                                 
                                 ; ***** SPI **************************
                                 ; SPDR - SPI Data Register
                                 .equ	SPDR0	= 0	; SPI Data Register bit 0
                                 .equ	SPDR1	= 1	; SPI Data Register bit 1
                                 .equ	SPDR2	= 2	; SPI Data Register bit 2
                                 .equ	SPDR3	= 3	; SPI Data Register bit 3
                                 .equ	SPDR4	= 4	; SPI Data Register bit 4
                                 .equ	SPDR5	= 5	; SPI Data Register bit 5
                                 .equ	SPDR6	= 6	; SPI Data Register bit 6
                                 .equ	SPDR7	= 7	; SPI Data Register bit 7
                                 
                                 ; SPSR - SPI Status Register
                                 .equ	SPI2X	= 0	; Double SPI Speed Bit
                                 .equ	WCOL	= 6	; Write Collision Flag
                                 .equ	SPIF	= 7	; SPI Interrupt Flag
                                 
                                 ; SPCR - SPI Control Register
                                 .equ	SPR0	= 0	; SPI Clock Rate Select 0
                                 .equ	SPR1	= 1	; SPI Clock Rate Select 1
                                 .equ	CPHA	= 2	; Clock Phase
                                 .equ	CPOL	= 3	; Clock polarity
                                 .equ	MSTR	= 4	; Master/Slave Select
                                 .equ	DORD	= 5	; Data Order
                                 .equ	SPE	= 6	; SPI Enable
                                 .equ	SPIE	= 7	; SPI Interrupt Enable
                                 
                                 
                                 ; ***** USART ************************
                                 ; UDR - USART I/O Data Register
                                 .equ	UDR0	= 0	; USART I/O Data Register bit 0
                                 .equ	UDR1	= 1	; USART I/O Data Register bit 1
                                 .equ	UDR2	= 2	; USART I/O Data Register bit 2
                                 .equ	UDR3	= 3	; USART I/O Data Register bit 3
                                 .equ	UDR4	= 4	; USART I/O Data Register bit 4
                                 .equ	UDR5	= 5	; USART I/O Data Register bit 5
                                 .equ	UDR6	= 6	; USART I/O Data Register bit 6
                                 .equ	UDR7	= 7	; USART I/O Data Register bit 7
                                 
                                 ; UCSRA - USART Control and Status Register A
                                 .equ	USR	= UCSRA	; For compatibility
                                 .equ	MPCM	= 0	; Multi-processor Communication Mode
                                 .equ	U2X	= 1	; Double the USART transmission speed
                                 .equ	UPE	= 2	; Parity Error
                                 .equ	PE	= UPE	; For compatibility
                                 .equ	DOR	= 3	; Data overRun
                                 .equ	FE	= 4	; Framing Error
                                 .equ	UDRE	= 5	; USART Data Register Empty
                                 .equ	TXC	= 6	; USART Transmitt Complete
                                 .equ	RXC	= 7	; USART Receive Complete
                                 
                                 ; UCSRB - USART Control and Status Register B
                                 .equ	UCR	= UCSRB	; For compatibility
                                 .equ	TXB8	= 0	; Transmit Data Bit 8
                                 .equ	RXB8	= 1	; Receive Data Bit 8
                                 .equ	UCSZ2	= 2	; Character Size
                                 .equ	CHR9	= UCSZ2	; For compatibility
                                 .equ	TXEN	= 3	; Transmitter Enable
                                 .equ	RXEN	= 4	; Receiver Enable
                                 .equ	UDRIE	= 5	; USART Data register Empty Interrupt Enable
                                 .equ	TXCIE	= 6	; TX Complete Interrupt Enable
                                 .equ	RXCIE	= 7	; RX Complete Interrupt Enable
                                 
                                 ; UCSRC - USART Control and Status Register C
                                 .equ	UCPOL	= 0	; Clock Polarity
                                 .equ	UCSZ0	= 1	; Character Size
                                 .equ	UCSZ1	= 2	; Character Size
                                 .equ	USBS	= 3	; Stop Bit Select
                                 .equ	UPM0	= 4	; Parity Mode Bit 0
                                 .equ	UPM1	= 5	; Parity Mode Bit 1
                                 .equ	UMSEL	= 6	; USART Mode Select
                                 .equ	URSEL	= 7	; Register Select
                                 
                                 .equ	UBRRHI	= UBRRH	; For compatibility
                                 
                                 ; ***** ANALOG_COMPARATOR ************
                                 ; SFIOR - Special Function IO Register
                                 .equ	ACME	= 3	; Analog Comparator Multiplexer Enable
                                 
                                 ; ACSR - Analog Comparator Control And Status Register
                                 .equ	ACIS0	= 0	; Analog Comparator Interrupt Mode Select bit 0
                                 .equ	ACIS1	= 1	; Analog Comparator Interrupt Mode Select bit 1
                                 .equ	ACIC	= 2	; Analog Comparator Input Capture Enable
                                 .equ	ACIE	= 3	; Analog Comparator Interrupt Enable
                                 .equ	ACI	= 4	; Analog Comparator Interrupt Flag
                                 .equ	ACO	= 5	; Analog Compare Output
                                 .equ	ACBG	= 6	; Analog Comparator Bandgap Select
                                 .equ	ACD	= 7	; Analog Comparator Disable
                                 
                                 
                                 ; ***** AD_CONVERTER *****************
                                 ; ADMUX - The ADC multiplexer Selection Register
                                 .equ	MUX0	= 0	; Analog Channel and Gain Selection Bits
                                 .equ	MUX1	= 1	; Analog Channel and Gain Selection Bits
                                 .equ	MUX2	= 2	; Analog Channel and Gain Selection Bits
                                 .equ	MUX3	= 3	; Analog Channel and Gain Selection Bits
                                 .equ	MUX4	= 4	; Analog Channel and Gain Selection Bits
                                 .equ	ADLAR	= 5	; Left Adjust Result
                                 .equ	REFS0	= 6	; Reference Selection Bit 0
                                 .equ	REFS1	= 7	; Reference Selection Bit 1
                                 
                                 ; ADCSRA - The ADC Control and Status register
                                 .equ	ADCSR	= ADCSRA	; For compatibility
                                 .equ	ADPS0	= 0	; ADC  Prescaler Select Bits
                                 .equ	ADPS1	= 1	; ADC  Prescaler Select Bits
                                 .equ	ADPS2	= 2	; ADC  Prescaler Select Bits
                                 .equ	ADIE	= 3	; ADC Interrupt Enable
                                 .equ	ADIF	= 4	; ADC Interrupt Flag
                                 .equ	ADATE	= 5	; When this bit is written to one,the Timer/Counter2 prescaler will be reset.The bit will be cleared by hardware after the operation is performed.Writing a zero to this bit will have no effect.This bit will always be read as zero if Timer/C                                 ounter2 is clocked by the internal CPU clock.If this bit is written when Timer/Counter2 is operating in asynchronous mode,the bit will remain one until the prescaler has been reset.
                                 .equ	ADFR	= ADATE	; For compatibility
                                 .equ	ADSC	= 6	; ADC Start Conversion
                                 .equ	ADEN	= 7	; ADC Enable
                                 
                                 ; ADCH - ADC Data Register High Byte
                                 .equ	ADCH0	= 0	; ADC Data Register High Byte Bit 0
                                 .equ	ADCH1	= 1	; ADC Data Register High Byte Bit 1
                                 .equ	ADCH2	= 2	; ADC Data Register High Byte Bit 2
                                 .equ	ADCH3	= 3	; ADC Data Register High Byte Bit 3
                                 .equ	ADCH4	= 4	; ADC Data Register High Byte Bit 4
                                 .equ	ADCH5	= 5	; ADC Data Register High Byte Bit 5
                                 .equ	ADCH6	= 6	; ADC Data Register High Byte Bit 6
                                 .equ	ADCH7	= 7	; ADC Data Register High Byte Bit 7
                                 
                                 ; ADCL - ADC Data Register Low Byte
                                 .equ	ADCL0	= 0	; ADC Data Register Low Byte Bit 0
                                 .equ	ADCL1	= 1	; ADC Data Register Low Byte Bit 1
                                 .equ	ADCL2	= 2	; ADC Data Register Low Byte Bit 2
                                 .equ	ADCL3	= 3	; ADC Data Register Low Byte Bit 3
                                 .equ	ADCL4	= 4	; ADC Data Register Low Byte Bit 4
                                 .equ	ADCL5	= 5	; ADC Data Register Low Byte Bit 5
                                 .equ	ADCL6	= 6	; ADC Data Register Low Byte Bit 6
                                 .equ	ADCL7	= 7	; ADC Data Register Low Byte Bit 7
                                 
                                 ; SFIOR - Special Function IO Register
                                 .equ	ADTS0	= 5	; ADC Auto Trigger Source 0
                                 .equ	ADTS1	= 6	; ADC Auto Trigger Source 1
                                 .equ	ADTS2	= 7	; ADC Auto Trigger Source 2
                                 
                                 
                                 ; ***** PORTA ************************
                                 ; PORTA - Port A Data Register
                                 .equ	PORTA0	= 0	; Port A Data Register bit 0
                                 .equ	PA0	= 0	; For compatibility
                                 .equ	PORTA1	= 1	; Port A Data Register bit 1
                                 .equ	PA1	= 1	; For compatibility
                                 .equ	PORTA2	= 2	; Port A Data Register bit 2
                                 .equ	PA2	= 2	; For compatibility
                                 .equ	PORTA3	= 3	; Port A Data Register bit 3
                                 .equ	PA3	= 3	; For compatibility
                                 .equ	PORTA4	= 4	; Port A Data Register bit 4
                                 .equ	PA4	= 4	; For compatibility
                                 .equ	PORTA5	= 5	; Port A Data Register bit 5
                                 .equ	PA5	= 5	; For compatibility
                                 .equ	PORTA6	= 6	; Port A Data Register bit 6
                                 .equ	PA6	= 6	; For compatibility
                                 .equ	PORTA7	= 7	; Port A Data Register bit 7
                                 .equ	PA7	= 7	; For compatibility
                                 
                                 ; DDRA - Port A Data Direction Register
                                 .equ	DDA0	= 0	; Data Direction Register, Port A, bit 0
                                 .equ	DDA1	= 1	; Data Direction Register, Port A, bit 1
                                 .equ	DDA2	= 2	; Data Direction Register, Port A, bit 2
                                 .equ	DDA3	= 3	; Data Direction Register, Port A, bit 3
                                 .equ	DDA4	= 4	; Data Direction Register, Port A, bit 4
                                 .equ	DDA5	= 5	; Data Direction Register, Port A, bit 5
                                 .equ	DDA6	= 6	; Data Direction Register, Port A, bit 6
                                 .equ	DDA7	= 7	; Data Direction Register, Port A, bit 7
                                 
                                 ; PINA - Port A Input Pins
                                 .equ	PINA0	= 0	; Input Pins, Port A bit 0
                                 .equ	PINA1	= 1	; Input Pins, Port A bit 1
                                 .equ	PINA2	= 2	; Input Pins, Port A bit 2
                                 .equ	PINA3	= 3	; Input Pins, Port A bit 3
                                 .equ	PINA4	= 4	; Input Pins, Port A bit 4
                                 .equ	PINA5	= 5	; Input Pins, Port A bit 5
                                 .equ	PINA6	= 6	; Input Pins, Port A bit 6
                                 .equ	PINA7	= 7	; Input Pins, Port A bit 7
                                 
                                 
                                 ; ***** PORTB ************************
                                 ; PORTB - Port B Data Register
                                 .equ	PORTB0	= 0	; Port B Data Register bit 0
                                 .equ	PB0	= 0	; For compatibility
                                 .equ	PORTB1	= 1	; Port B Data Register bit 1
                                 .equ	PB1	= 1	; For compatibility
                                 .equ	PORTB2	= 2	; Port B Data Register bit 2
                                 .equ	PB2	= 2	; For compatibility
                                 .equ	PORTB3	= 3	; Port B Data Register bit 3
                                 .equ	PB3	= 3	; For compatibility
                                 .equ	PORTB4	= 4	; Port B Data Register bit 4
                                 .equ	PB4	= 4	; For compatibility
                                 .equ	PORTB5	= 5	; Port B Data Register bit 5
                                 .equ	PB5	= 5	; For compatibility
                                 .equ	PORTB6	= 6	; Port B Data Register bit 6
                                 .equ	PB6	= 6	; For compatibility
                                 .equ	PORTB7	= 7	; Port B Data Register bit 7
                                 .equ	PB7	= 7	; For compatibility
                                 
                                 ; DDRB - Port B Data Direction Register
                                 .equ	DDB0	= 0	; Port B Data Direction Register bit 0
                                 .equ	DDB1	= 1	; Port B Data Direction Register bit 1
                                 .equ	DDB2	= 2	; Port B Data Direction Register bit 2
                                 .equ	DDB3	= 3	; Port B Data Direction Register bit 3
                                 .equ	DDB4	= 4	; Port B Data Direction Register bit 4
                                 .equ	DDB5	= 5	; Port B Data Direction Register bit 5
                                 .equ	DDB6	= 6	; Port B Data Direction Register bit 6
                                 .equ	DDB7	= 7	; Port B Data Direction Register bit 7
                                 
                                 ; PINB - Port B Input Pins
                                 .equ	PINB0	= 0	; Port B Input Pins bit 0
                                 .equ	PINB1	= 1	; Port B Input Pins bit 1
                                 .equ	PINB2	= 2	; Port B Input Pins bit 2
                                 .equ	PINB3	= 3	; Port B Input Pins bit 3
                                 .equ	PINB4	= 4	; Port B Input Pins bit 4
                                 .equ	PINB5	= 5	; Port B Input Pins bit 5
                                 .equ	PINB6	= 6	; Port B Input Pins bit 6
                                 .equ	PINB7	= 7	; Port B Input Pins bit 7
                                 
                                 
                                 ; ***** PORTC ************************
                                 ; PORTC - Port C Data Register
                                 .equ	PORTC0	= 0	; Port C Data Register bit 0
                                 .equ	PC0	= 0	; For compatibility
                                 .equ	PORTC1	= 1	; Port C Data Register bit 1
                                 .equ	PC1	= 1	; For compatibility
                                 .equ	PORTC2	= 2	; Port C Data Register bit 2
                                 .equ	PC2	= 2	; For compatibility
                                 .equ	PORTC3	= 3	; Port C Data Register bit 3
                                 .equ	PC3	= 3	; For compatibility
                                 .equ	PORTC4	= 4	; Port C Data Register bit 4
                                 .equ	PC4	= 4	; For compatibility
                                 .equ	PORTC5	= 5	; Port C Data Register bit 5
                                 .equ	PC5	= 5	; For compatibility
                                 .equ	PORTC6	= 6	; Port C Data Register bit 6
                                 .equ	PC6	= 6	; For compatibility
                                 .equ	PORTC7	= 7	; Port C Data Register bit 7
                                 .equ	PC7	= 7	; For compatibility
                                 
                                 ; DDRC - Port C Data Direction Register
                                 .equ	DDC0	= 0	; Port C Data Direction Register bit 0
                                 .equ	DDC1	= 1	; Port C Data Direction Register bit 1
                                 .equ	DDC2	= 2	; Port C Data Direction Register bit 2
                                 .equ	DDC3	= 3	; Port C Data Direction Register bit 3
                                 .equ	DDC4	= 4	; Port C Data Direction Register bit 4
                                 .equ	DDC5	= 5	; Port C Data Direction Register bit 5
                                 .equ	DDC6	= 6	; Port C Data Direction Register bit 6
                                 .equ	DDC7	= 7	; Port C Data Direction Register bit 7
                                 
                                 ; PINC - Port C Input Pins
                                 .equ	PINC0	= 0	; Port C Input Pins bit 0
                                 .equ	PINC1	= 1	; Port C Input Pins bit 1
                                 .equ	PINC2	= 2	; Port C Input Pins bit 2
                                 .equ	PINC3	= 3	; Port C Input Pins bit 3
                                 .equ	PINC4	= 4	; Port C Input Pins bit 4
                                 .equ	PINC5	= 5	; Port C Input Pins bit 5
                                 .equ	PINC6	= 6	; Port C Input Pins bit 6
                                 .equ	PINC7	= 7	; Port C Input Pins bit 7
                                 
                                 
                                 ; ***** PORTD ************************
                                 ; PORTD - Port D Data Register
                                 .equ	PORTD0	= 0	; Port D Data Register bit 0
                                 .equ	PD0	= 0	; For compatibility
                                 .equ	PORTD1	= 1	; Port D Data Register bit 1
                                 .equ	PD1	= 1	; For compatibility
                                 .equ	PORTD2	= 2	; Port D Data Register bit 2
                                 .equ	PD2	= 2	; For compatibility
                                 .equ	PORTD3	= 3	; Port D Data Register bit 3
                                 .equ	PD3	= 3	; For compatibility
                                 .equ	PORTD4	= 4	; Port D Data Register bit 4
                                 .equ	PD4	= 4	; For compatibility
                                 .equ	PORTD5	= 5	; Port D Data Register bit 5
                                 .equ	PD5	= 5	; For compatibility
                                 .equ	PORTD6	= 6	; Port D Data Register bit 6
                                 .equ	PD6	= 6	; For compatibility
                                 .equ	PORTD7	= 7	; Port D Data Register bit 7
                                 .equ	PD7	= 7	; For compatibility
                                 
                                 ; DDRD - Port D Data Direction Register
                                 .equ	DDD0	= 0	; Port D Data Direction Register bit 0
                                 .equ	DDD1	= 1	; Port D Data Direction Register bit 1
                                 .equ	DDD2	= 2	; Port D Data Direction Register bit 2
                                 .equ	DDD3	= 3	; Port D Data Direction Register bit 3
                                 .equ	DDD4	= 4	; Port D Data Direction Register bit 4
                                 .equ	DDD5	= 5	; Port D Data Direction Register bit 5
                                 .equ	DDD6	= 6	; Port D Data Direction Register bit 6
                                 .equ	DDD7	= 7	; Port D Data Direction Register bit 7
                                 
                                 ; PIND - Port D Input Pins
                                 .equ	PIND0	= 0	; Port D Input Pins bit 0
                                 .equ	PIND1	= 1	; Port D Input Pins bit 1
                                 .equ	PIND2	= 2	; Port D Input Pins bit 2
                                 .equ	PIND3	= 3	; Port D Input Pins bit 3
                                 .equ	PIND4	= 4	; Port D Input Pins bit 4
                                 .equ	PIND5	= 5	; Port D Input Pins bit 5
                                 .equ	PIND6	= 6	; Port D Input Pins bit 6
                                 .equ	PIND7	= 7	; Port D Input Pins bit 7
                                 
                                 
                                 ; ***** CPU **************************
                                 ; SREG - Status Register
                                 .equ	SREG_C	= 0	; Carry Flag
                                 .equ	SREG_Z	= 1	; Zero Flag
                                 .equ	SREG_N	= 2	; Negative Flag
                                 .equ	SREG_V	= 3	; Two's Complement Overflow Flag
                                 .equ	SREG_S	= 4	; Sign Bit
                                 .equ	SREG_H	= 5	; Half Carry Flag
                                 .equ	SREG_T	= 6	; Bit Copy Storage
                                 .equ	SREG_I	= 7	; Global Interrupt Enable
                                 
                                 ; MCUCR - MCU Control Register
                                 ;.equ	ISC00	= 0	; Interrupt Sense Control 0 Bit 0
                                 ;.equ	ISC01	= 1	; Interrupt Sense Control 0 Bit 1
                                 ;.equ	ISC10	= 2	; Interrupt Sense Control 1 Bit 0
                                 ;.equ	ISC11	= 3	; Interrupt Sense Control 1 Bit 1
                                 .equ	SM0	= 4	; Sleep Mode Select
                                 .equ	SM1	= 5	; Sleep Mode Select
                                 .equ	SM2	= 6	; Sleep Mode Select
                                 .equ	SE	= 7	; Sleep Enable
                                 
                                 ; MCUCSR - MCU Control And Status Register
                                 .equ	MCUSR	= MCUCSR	; For compatibility
                                 .equ	PORF	= 0	; Power-on reset flag
                                 .equ	EXTRF	= 1	; External Reset Flag
                                 .equ	BORF	= 2	; Brown-out Reset Flag
                                 .equ	WDRF	= 3	; Watchdog Reset Flag
                                 .equ	JTRF	= 4	; JTAG Reset Flag
                                 .equ	JTD	= 7	; JTAG Interface Disable
                                 
                                 ; OSCCAL - Oscillator Calibration Value
                                 .equ	CAL0	= 0	; Oscillator Calibration Value Bit0
                                 .equ	CAL1	= 1	; Oscillator Calibration Value Bit1
                                 .equ	CAL2	= 2	; Oscillator Calibration Value Bit2
                                 .equ	CAL3	= 3	; Oscillator Calibration Value Bit3
                                 .equ	CAL4	= 4	; Oscillator Calibration Value Bit4
                                 .equ	CAL5	= 5	; Oscillator Calibration Value Bit5
                                 .equ	CAL6	= 6	; Oscillator Calibration Value Bit6
                                 .equ	CAL7	= 7	; Oscillator Calibration Value Bit7
                                 
                                 ; SFIOR - Special Function IO Register
                                 .equ	PSR10	= 0	; Prescaler Reset Timer/Counter1&0
                                 .equ	PSR2	= 1	; Prescaler Reset Timer/Counter2
                                 .equ	PUD	= 2	; Pull-up Disable
                                 
                                 
                                 ; ***** BOOT_LOAD ********************
                                 ; SPMCR - Store Program Memory Control Register
                                 .equ	SPMEN	= 0	; Store Program Memory Enable
                                 .equ	PGERS	= 1	; Page Erase
                                 .equ	PGWRT	= 2	; Page Write
                                 .equ	BLBSET	= 3	; Boot Lock Bit Set
                                 .equ	RWWSRE	= 4	; Read While Write secion read enable
                                 .equ	ASRE	= RWWSRE	; For compatibility
                                 .equ	RWWSB	= 6	; Read While Write Section Busy
                                 .equ	ASB	= RWWSB	; For compatibility
                                 .equ	SPMIE	= 7	; SPM Interrupt Enable
                                 
                                 
                                 ; ***** TWI **************************
                                 ; TWBR - TWI Bit Rate register
                                 .equ	TWBR0	= 0	; 
                                 .equ	TWBR1	= 1	; 
                                 .equ	TWBR2	= 2	; 
                                 .equ	TWBR3	= 3	; 
                                 .equ	TWBR4	= 4	; 
                                 .equ	TWBR5	= 5	; 
                                 .equ	TWBR6	= 6	; 
                                 .equ	TWBR7	= 7	; 
                                 
                                 ; TWCR - TWI Control Register
                                 .equ	TWIE	= 0	; TWI Interrupt Enable
                                 .equ	TWEN	= 2	; TWI Enable Bit
                                 .equ	TWWC	= 3	; TWI Write Collition Flag
                                 .equ	TWSTO	= 4	; TWI Stop Condition Bit
                                 .equ	TWSTA	= 5	; TWI Start Condition Bit
                                 .equ	TWEA	= 6	; TWI Enable Acknowledge Bit
                                 .equ	TWINT	= 7	; TWI Interrupt Flag
                                 
                                 ; TWSR - TWI Status Register
                                 .equ	TWPS0	= 0	; TWI Prescaler bits
                                 .equ	TWPS1	= 1	; TWI Prescaler bits
                                 .equ	TWS3	= 3	; TWI Status
                                 .equ	TWS4	= 4	; TWI Status
                                 .equ	TWS5	= 5	; TWI Status
                                 .equ	TWS6	= 6	; TWI Status
                                 .equ	TWS7	= 7	; TWI Status
                                 
                                 ; TWDR - TWI Data register
                                 .equ	TWD0	= 0	; TWI Data Register Bit 0
                                 .equ	TWD1	= 1	; TWI Data Register Bit 1
                                 .equ	TWD2	= 2	; TWI Data Register Bit 2
                                 .equ	TWD3	= 3	; TWI Data Register Bit 3
                                 .equ	TWD4	= 4	; TWI Data Register Bit 4
                                 .equ	TWD5	= 5	; TWI Data Register Bit 5
                                 .equ	TWD6	= 6	; TWI Data Register Bit 6
                                 .equ	TWD7	= 7	; TWI Data Register Bit 7
                                 
                                 ; TWAR - TWI (Slave) Address register
                                 .equ	TWGCE	= 0	; TWI General Call Recognition Enable Bit
                                 .equ	TWA0	= 1	; TWI (Slave) Address register Bit 0
                                 .equ	TWA1	= 2	; TWI (Slave) Address register Bit 1
                                 .equ	TWA2	= 3	; TWI (Slave) Address register Bit 2
                                 .equ	TWA3	= 4	; TWI (Slave) Address register Bit 3
                                 .equ	TWA4	= 5	; TWI (Slave) Address register Bit 4
                                 .equ	TWA5	= 6	; TWI (Slave) Address register Bit 5
                                 .equ	TWA6	= 7	; TWI (Slave) Address register Bit 6
                                 
                                 
                                 
                                 ; ***** LOCKSBITS ********************************************************
                                 .equ	LB1	= 0	; Lock bit
                                 .equ	LB2	= 1	; Lock bit
                                 .equ	BLB01	= 2	; Boot Lock bit
                                 .equ	BLB02	= 3	; Boot Lock bit
                                 .equ	BLB11	= 4	; Boot lock bit
                                 .equ	BLB12	= 5	; Boot lock bit
                                 
                                 
                                 ; ***** FUSES ************************************************************
                                 ; LOW fuse bits
                                 .equ	CKSEL0	= 0	; Select Clock Source
                                 .equ	CKSEL1	= 1	; Select Clock Source
                                 .equ	CKSEL2	= 2	; Select Clock Source
                                 .equ	CKSEL3	= 3	; Select Clock Source
                                 .equ	BODEN	= 6	; Brown out detector enable
                                 .equ	BODLEVEL	= 7	; Brown out detector trigger level
                                 
                                 ; HIGH fuse bits
                                 .equ	BOOTRST	= 0	; Select Reset Vector
                                 .equ	BOOTSZ0	= 1	; Select Boot Size
                                 .equ	BOOTSZ1	= 2	; Select Boot Size
                                 .equ	EESAVE	= 3	; EEPROM memory is preserved through chip erase
                                 .equ	SPIEN	= 5	; Enable Serial programming and Data Downloading
                                 .equ	JTAGEN	= 6	; Enable JTAG
                                 .equ	OCDEN	= 7	; Enable OCD
                                 
                                 
                                 
                                 ; ***** CPU REGISTER DEFINITIONS *****************************************
                                 .def	XH	= r27
                                 .def	XL	= r26
                                 .def	YH	= r29
                                 .def	YL	= r28
                                 .def	ZH	= r31
                                 .def	ZL	= r30
                                 
                                 
                                 
                                 ; ***** DATA MEMORY DECLARATIONS *****************************************
                                 .equ	FLASHEND	= 0x3fff	; Note: Word address
                                 .equ	IOEND	= 0x003f
                                 .equ	SRAM_START	= 0x0060
                                 .equ	SRAM_SIZE	= 2048
                                 .equ	RAMEND	= 0x085f
                                 .equ	XRAMEND	= 0x0000
                                 .equ	E2END	= 0x03ff
                                 .equ	EEPROMEND	= 0x03ff
                                 .equ	EEADRBITS	= 10
                                 #pragma AVRPART MEMORY PROG_FLASH 32768
                                 #pragma AVRPART MEMORY EEPROM 1024
                                 #pragma AVRPART MEMORY INT_SRAM SIZE 2048
                                 #pragma AVRPART MEMORY INT_SRAM START_ADDR 0x60
                                 
                                 
                                 
                                 ; ***** BOOTLOADER DECLARATIONS ******************************************
                                 .equ	NRWW_START_ADDR	= 0x3800
                                 .equ	NRWW_STOP_ADDR	= 0x3fff
                                 .equ	RWW_START_ADDR	= 0x0
                                 .equ	RWW_STOP_ADDR	= 0x37ff
                                 .equ	PAGESIZE	= 64
                                 .equ	FIRSTBOOTSTART	= 0x3f00
                                 .equ	SECONDBOOTSTART	= 0x3e00
                                 .equ	THIRDBOOTSTART	= 0x3c00
                                 .equ	FOURTHBOOTSTART	= 0x3800
                                 .equ	SMALLBOOTSTART	= FIRSTBOOTSTART
                                 .equ	LARGEBOOTSTART	= FOURTHBOOTSTART
                                 
                                 
                                 
                                 ; ***** INTERRUPT VECTORS ************************************************
                                 .equ	INT0addr	= 0x0002	; External Interrupt Request 0
                                 .equ	INT1addr	= 0x0004	; External Interrupt Request 1
                                 .equ	INT2addr	= 0x0006	; External Interrupt Request 2
                                 .equ	OC2addr	= 0x0008	; Timer/Counter2 Compare Match
                                 .equ	OVF2addr	= 0x000a	; Timer/Counter2 Overflow
                                 .equ	ICP1addr	= 0x000c	; Timer/Counter1 Capture Event
                                 .equ	OC1Aaddr	= 0x000e	; Timer/Counter1 Compare Match A
                                 .equ	OC1Baddr	= 0x0010	; Timer/Counter1 Compare Match B
                                 .equ	OVF1addr	= 0x0012	; Timer/Counter1 Overflow
                                 .equ	OC0addr	= 0x0014	; Timer/Counter0 Compare Match
                                 .equ	OVF0addr	= 0x0016	; Timer/Counter0 Overflow
                                 .equ	SPIaddr	= 0x0018	; Serial Transfer Complete
                                 .equ	URXCaddr	= 0x001a	; USART, Rx Complete
                                 .equ	UDREaddr	= 0x001c	; USART Data Register Empty
                                 .equ	UTXCaddr	= 0x001e	; USART, Tx Complete
                                 .equ	ADCCaddr	= 0x0020	; ADC Conversion Complete
                                 .equ	ERDYaddr	= 0x0022	; EEPROM Ready
                                 .equ	ACIaddr	= 0x0024	; Analog Comparator
                                 .equ	TWIaddr	= 0x0026	; 2-wire Serial Interface
                                 .equ	SPMRaddr	= 0x0028	; Store Program Memory Ready
                                 
                                 .equ	INT_VECTORS_SIZE	= 42	; size in words
                                 
                                 #endif  /* _M32DEF_INC_ */
                                 
                                 
                                 ; AssemblerApplication1.asm
                                 ;
                                 ; Created: 4/19/2020 6:26:35 PM
                                 ; Author : Hooman tahayori
                                 ; 
                                 ; UI: '=' for performing frequency and '+' for performing Duty Cycle
                                 ;     this UI has no clear buttom to recheck your input, I WAS TIRED FOR THAT
                                 ;     some times may put your finger on the buttom for a long time, this means alot of input (it doesn't work at rising of fallin edge)
                                 ;     the clock frequency must 4MHz or less, this is so important to have correct frequency and true input(HOLD Delay of buttoms are low becarefull)
                                 ;==================================================================================================================================================== 
                                 ; [READ ME] This is a assembly project which produce squre wave in the output. 
                                 ; Whit a matrix keypad you can chang frequency[100Hz : 1000Hz] and duty cycle[0%:100%].
                                 ; NO NEED EXTRA BUTTOM TO COMFORM THE NUMBER YOU WANT but after you enter your full number, 
                                 ; press '=' to confirm frequency in range [100 : 1000] and press '+'  to confirm duty cycle in range [0 : 100] to MCU.
                                 ; ABOUT TIME: I didn't use deley for makking time, it's terrible for RTOS designe. I preffered to use counter and skipping tasks._see in codes_ 
                                 ; I exprinced that each buttom hold about 100:150< mSEC and a buttom will press twice after 300:400> mSEC _seccond buttom will press after 300 msec_
                                 ; This MCU work at 4MHz. So each command _clock_ wast 1/4 uSEC. You can calculate how many should your counter counts to make that delay. my counter was
                                 ; in R18 , R17 16 bit full. and for clock 4MHz makes about 300mSEC delay.
                                 ; For making that time,R18, R17 sets on 0xFFFF at pressed buttom, MCU won't see keypad changes untill they become 0x0000
                                 ; more info about UI, registers, challanges, etc will put as a command.
                                 ;-----------------------------------------------------------------------ARCHITECTURE------------------
                                 ;R18-R17 is for counting. 16 bits. used in wait 300mSec for keypad input.
                                 ;R16 is a temp register for driving values into IN, OUT, DDR, PORT, etc registers
                                 ;R20 is fixed on 0x0A
                                 ;R19 is fixed on 0x00
                                 ;R31, R30 ON ROUND NUMBER wich makes delay
                                 ;R29, R28 OFF ROUND NUMBER wich makes delay
                                 ;R0 : R6 are used in arithmetic functions and reserved
                                 ;R21 and R23 are used in arithmetic functions (DEVISION) and reserved 
                                 
                                 .INCLUDE "M32DEF.INC"
                                 
                                 ;***** Created: 2011-02-09 12:03 ******* Source: ATmega32.xml ************
                                 ;*************************************************************************
                                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                                 ;* 
                                 ;* Number            : AVR000
                                 ;* File Name         : "m32def.inc"
                                 ;* Title             : Register/Bit Definitions for the ATmega32
                                 ;* Date              : 2011-02-09
                                 ;* Version           : 2.35
                                 ;* Support E-mail    : avr@atmel.com
                                 ;* Target MCU        : ATmega32
                                 ;* 
                                 ;* DESCRIPTION
                                 ;* When including this file in the assembly program file, all I/O register 
                                 ;* names and I/O register bit names appearing in the data book can be used.
                                 ;* In addition, the six registers forming the three data pointers X, Y and 
                                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                                 ;* SRAM is also defined 
                                 ;* 
                                 ;* The Register names are represented by their hexadecimal address.
                                 ;* 
                                 ;* The Register Bit names are represented by their bit number (0-7).
                                 ;* 
                                 ;* Please observe the difference in using the bit names with instructions
                                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                                 ;* (skip if bit in register set/cleared). The following example illustrates
                                 ;* this:
                                 ;* 
                                 ;* in    r16,PORTB             ;read PORTB latch
                                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                                 ;* out   PORTB,r16             ;output to PORTB
                                 ;* 
                                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                                 ;* rjmp  TOV0_is_set           ;jump if set
                                 ;* ...                         ;otherwise do something else
                                 ;*************************************************************************
                                 
                                 #ifndef _M32DEF_INC_
                                 
                                 #endif  /* _M32DEF_INC_ */
                                 
                                 ;-------------------------------
                                 ;-----------------------RAM -----
                                 .EQU golden_T_2_addr		 = 0x0061
                                 .EQU golden_T_1_addr		 = 0x0062
                                 .EQU golden_T_0_addr		 = 0x0063
                                 .EQU in_frequency_H_addr	  = 0x0064
                                 .EQU in_frequency_L_addr	  = 0x0065
                                 .EQU DutyCycle_addr			 = 0x0066
                                 .EQU tottal_round_H_addr	 = 0x0067
                                 .EQU tottal_round_L_addr	 = 0x0068
                                 .EQU ON_round_H_addr		 = 0x0069
                                 .EQU ON_round_L_addr		 = 0x0070
                                 .EQU OFF_round_H_addr		 = 0x0071
                                 .EQU OFF_round_L_addr		 = 0x0072
                                 ;----------------------Constant numbers-----
                                 .EQU loop_freq_0 = 0xB0
                                 .EQU loop_freq_1 = 0xAD
                                 .EQU loop_freq_2 = 0x01
                                 
                                 .EQU ten_num = 0x0A
                                 .EQU zero_num = 0x00
                                 
                                 .EQU yekan_full = 0xFF
                                 .EQU dahgan_full =0xFF
                                 ;----------------------register defines----
                                 .DEF temp = R16
                                 .DEF KeyPad_counter_L = R17
                                 .DEF KeyPad_counter_H = R18
                                 .DEF clear = R19
                                 .DEF ten = R20
                                 ;-------------------------------------DISGARD THIS------------------
                                        ;.EQU state = (R17) _It should be the address_  Beacuse of the LINE 41, when port became low by MCU ,the current flow from the pins hang them  
                                 		  ;low and did'nt come back to high, in another hand i could'nt put those high by exprience. I tried to use state of a bottom to wait some
                                 		  ; times, if the bottom was not pressed i can use line 41.(The pins acctully become Short Circut for a while) But I examine ussing small 
                                 		  ;Ressistor on the pins(3:0) to prevent this event. that was usefull and effective and easy.
                                        ;.EQU  key_on  = 0xFE ;It works like a timmer. it counts while the register become 0x00 and it means buttom is free
                                        ;.EQU  key_off  = 0x00
                                 ;----------------------------------------------------------------------------------------------------
                                 ;=============================configurations and initiolization==================================
000000 e030                      LDI R19 , zero_num   ;Constant number for clearring registers
000001 e04a                      LDI R20 , ten_num  ;Constant number 10 DEC. It used in multiplies in arithmetic functions
000002 2e23                       MOV R2 , clear    ;clearring R2 and R3, it is the initiollizing for multiplies in arithmetic functions
000003 2e33                       MOV R3 , clear
                                 
000004 eb50                      LDI R21 , loop_freq_0 ; R21 , R22 , R23 NEEDS FOR DEVIDER FUNCTION
000005 ea6d                      LDI R22 , loop_freq_1
000006 e071                      LDI R23 , loop_freq_2 
                                 ;------------------------------------------
000007 e008                      LDI temp , HIGH(RAMEND) ; SP set
000008 bf0e                      OUT SPH , temp
000009 e50f                      LDI R16 , LOW(RAMEND)
00000a bf0d                      OUT SPL , R16
                                 ;--------------
00000b ef00                      LDI R16 , 0xF0  
00000c bb01                      OUT DDRD , R16  ; High nible of PORTD sets as output and low nible of PORTD set as input.
00000d e000                      LDI R16 , 0x00  ; High nible input HZ
00000e bb02                      OUT PORTD , R16 ; High nible HZ and Low nible sets 0000
                                 
00000f ef0f                      LDI R16 , 0xFF ; I use PORTB for show the key pressed number
000010 bb07                      OUT DDRB , R16 ; PORTB set as output.
000011 e000                      LDI R16 , 0x00
000012 bb08                      OUT PORTB , R16 ; PORTB = 0x00
                                 
000013 ef0f                      LDI R16 , 0xFF ; I preffered to use port A for my wave
000014 bb0a                      OUT DDRA , R16 ; PORTA set as output.
000015 e000                      LDI R16 , 0x00
000016 bb0b                      OUT PORTA , R16 ; PORTA = 0x00
                                 ;--------------------------------------------------------------
000017 e302                      LDI temp,0x32  ; 0x32 = 50
000018 9300 0066                 STS DutyCycle_addr,temp ;duty cycle=50% init value
                                 ;---
00001a e004                      LDI temp,0x04
00001b 9300 0067                 STS tottal_round_H_addr, temp ;now we have tottal number of rounds for makking T period of input frequency  
00001d e40c                      LDI temp,0x4C
00001e 9300 0068                 STS tottal_round_L_addr, temp
                                 
000020 e002                      LDI temp,0x02
000021 9300 0071                 STS OFF_round_H_addr, temp ;now we have tottal number of rounds for makking T period of input frequency  
000023 e206                      LDI temp,0x26
000024 9300 0072                 STS OFF_round_L_addr, temp
                                 
000026 e002                      LDI temp,0x02
000027 9300 0069                 STS ON_round_H_addr, temp ;now we have tottal number of rounds for makking T period of input frequency  
000029 e206                      LDI temp,0x26
00002a 9300 0070                 STS ON_round_L_addr, temp
                                 
00002c e0f2                      LDI R31,0x02
00002d e2e6                      LDI R30,0x26
                                 
00002e e0d2                      LDI R29,0x02
00002f e2c6                      LDI R28,0x26
                                 
                                 ;NOTE: 1100 rounds on + 1100 rounds off => f=100Hz , duty cycle = 50% THIS IS FOR CLOCK 8 MHz
                                 ;       44C HEX			44C HEX
                                 
                                 ;NOTE: 550 rounds on + 550 rounds off => f=100Hz , duty cycle = 50% THIS IS FOR CLOCK 4 MHz
                                 ;       226 HEX			226 HEX
                                 ;----------------------------------------------MAIN PROJECT----------------------------------------------------------------------  
                                 start:
000030 2311                      	TST R17				;Examine flag Z for condition  FOR MORE INFO ABOUT THIS, SEE LINE 11 AND 12 AND 13
000031 f011                      	BREQ yekan_0        ;If Z=1 _R17=0_ don't decreas R17. R17 is used to (as a counter) for skipping keypad input watching
000032 951a                      		DEC R17
000033 c013                      		RJMP Blinking_Task
                                 	yekan_0:		  				 ; I need mor bits to count more than 256
000034 2322                      	    TST R18
000035 f019                      		BREQ dahgan_0        ;If Z=1 _R18=0_ don't decreas R17. R17 is used to (as a counter) for skipping keypad input watching
000036 951a                      			DEC R17
000037 952a                      			DEC R18
000038 c00e                      		    RJMP Blinking_Task
                                 		dahgan_0:
                                 				;---------------------
000039 e000                      				LDI R16 , 0x00    ;low nible must be 0000  because did not work when it was F/ ROW DIEGNOSING
00003a bb02                      				OUT PORTD , R16   ; PORTD = 0000---- for dignossing ROW
                                 				;---------------------			
00003b 9b80                      				SBIS PIND , 0 ; IF BOTTOM PRESSED FROM ROW 0
00003c 940e 006b                 				 CALL Key_Press_Row0 ; GO FOR DIGNOSING THE COLUMN
00003e 9b81                      				SBIS PIND , 1
00003f 940e 007c                 				  CALL Key_Press_Row1			    
000041 9b82                      				SBIS PIND , 2
000042 940e 008d                 				  CALL Key_Press_Row2
000044 9b83                      				SBIS PIND , 3
000045 940e 009e                 				  CALL Key_Press_Row3 
                                                 ;---------------------
                                 				
                                 		   Blinking_Task:
                                 			   
                                 ;========R31 , R30 is for ON TIME			   
000047 23ee                      TST R30				;Examine flag Z for condition  FOR MORE INFO ABOUT THIS, SEE LINE 11 AND 12 AND 13
000048 f011                      	BREQ yekan_1        ;If Z=1 _R17=0_ don't decreas R17. R17 is used to (as a counter) for skipping keypad input watching
000049 95ea                      		DEC R30
00004a c012                      		RJMP LED_ON
                                 	yekan_1:		  				 ; I need mor bits to count more than 256
00004b 23ff                      	    TST R31
00004c f019                      		BREQ dahgan_1        ;If Z=1 _R18=0_ don't decreas R17. R17 is used to (as a counter) for skipping keypad input watching
00004d 95ea                      			DEC R30
00004e 95fa                      			DEC R31
00004f c00d                      		    RJMP LED_ON
                                 		dahgan_1:
                                 ;-------R29 , R28 is for OFF TIME
000050 23cc                      TST R28				;Examine flag Z for condition  FOR MORE INFO ABOUT THIS, SEE LINE 11 AND 12 AND 13
000051 f011                      	BREQ yekan_2        ;If Z=1 _R17=0_ don't decreas R17. R17 is used to (as a counter) for skipping keypad input watching
000052 95ca                      		DEC R28
000053 c013                      		RJMP LED_OFF
                                 	yekan_2:		  				 ; I need mor bits to count more than 256
000054 23dd                      	    TST R29
000055 f019                      		BREQ dahgan_2        ;If Z=1 _R18=0_ don't decreas R17. R17 is used to (as a counter) for skipping keypad input watching
000056 95ca                      			DEC R28
000057 95da                      			DEC R29
000058 c00e                      		    RJMP LED_OFF
                                 		dahgan_2:
000059 91f0 0069                 		LDS R31,ON_round_H_addr
00005b 91e0 0070                 		LDS R30,ON_round_L_addr
                                 		
                                 LED_ON:
00005d ef0f                          LDI R16,0xFF
00005e bb0b                          OUT PORTA,R16 
00005f 91d0 0071                 	LDS R29,OFF_round_H_addr
000061 91c0 0072                     LDS R28,OFF_round_L_addr
000063 0000                      	NOP ;calabrating...
000064 0000                      	NOP
000065 0000                      	NOP			 
000066 cfc9                      RJMP start
                                 
                                 LED_OFF:
000067 e000                        LDI R16,0x00
000068 bb0b                        OUT PORTA,R16
000069 0000                        NOP
00006a cfc5                      RJMP start
                                     
                                 ;======================================================================================================================================
                                 ;When the row dignosed, MCU will pass here to find wich column cause that pin low
                                 ;-------------------------------------------ROW 0 DIGNOSED LET'S CLEAR THE COLUMN---------------------------------------------------------
                                  Key_Press_Row0: ;Readding from keypad
00006b ee00                          LDI R16 , 0xE0 ;low nible must be 0000  because did not work when it was F
00006c bb02                      	OUT PORTD , R16 ; PORTD = 0111----
00006d 9b80                      	SBIS PIND , 0
00006e c040                      	  RJMP Show_00  ; to show the nomber on portb/ 04 means column0 row0
                                 	
00006f ed00                      	LDI R16 , 0xD0 ;low nible must be 0000  
000070 bb02                      	OUT PORTD , R16 ; PORTD = 1011----
000071 9b80                      	SBIS PIND , 0
000072 c041                      	  RJMP Show_10  ; to show the nomber on portb/ 04 means column1 row0
                                 
000073 eb00                      	LDI R16 , 0xB0 ;low nible must be 0000  
000074 bb02                      	OUT PORTD , R16 ; PORTD = 1101----
000075 9b80                      	SBIS PIND , 0
000076 c042                      	  RJMP Show_20  ; to show the nomber on portb/ 04 means column2 row0
                                 
000077 e700                      	LDI R16 , 0x70 ;low nible must be 0000  
000078 bb02                      	OUT PORTD , R16 ; PORTD = 1110----
000079 9b80                      	SBIS PIND , 0
00007a c043                      	  RJMP Show_30   ; to show the nomber on portb/ 04 means column3 row0
00007b cfb4                       RJMP start ; Some times row dignose and MCU will come here, but it would'nt find the column _maybe becuse of the noise_
                                 					 ; and continiue the trail wich is no need, this line is for unpredicted event _the column have'nt seen_
                                 					 ;I did'nt use RJMP Key_Press_Row0 beacuse i tried and some times it lock in this loop, start is much better
                                 ;------------------------------------------ROW 1 DIGNOSED LET'S CLEAR THE COLUMN--------------------------
                                  Key_Press_Row1: ;Readding from keypad
00007c ee00                          LDI R16 , 0xE0 ;low nible must be 0000  because did not work when it was F
00007d bb02                      	OUT PORTD , R16 ; PORTD = 0111----
00007e 9b81                      	SBIS PIND , 1
00007f c043                      	  RJMP Show_01  ; to show the nomber on portb/ 04 means column0 row1
                                 	
000080 ed00                      	LDI R16 , 0xD0 ;low nible must be 0000  
000081 bb02                      	OUT PORTD , R16 ; PORTD = 1011----
000082 9b81                      	SBIS PIND , 1
000083 c044                      	  RJMP Show_11  ; to show the nomber on portb/ 04 means column1 row1
                                 
000084 eb00                      	LDI R16 , 0xB0 ;low nible must be 0000  
000085 bb02                      	OUT PORTD , R16 ; PORTD = 1101----
000086 9b81                      	SBIS PIND , 1
000087 c045                      	  RJMP Show_21  ; to show the nomber on portb/ 04 means column2 row1
                                 
000088 e700                      	LDI R16 , 0x70 ;low nible must be 0000  
000089 bb02                      	OUT PORTD , R16 ; PORTD = 1110----
00008a 9b81                      	SBIS PIND , 1
00008b c046                      	  RJMP Show_31  ; to show the nomber on portb/ 04 means column3 row1
00008c cfa3                       RJMP start ; Some times row dignose and MCU will come here, but it would'nt find the column _maybe becuse of the noise_
                                 					 ; and continiue the trail wich is no need, this line is for unpredicted event _the column have'nt seen_
                                 					 ;I did'nt use RJMP Key_Press_Row1 beacuse i tried and some times it lock in this loop, start is much better
                                 ;------------------------------------------ROW 2 DIGNOSED LET'S CLEAR THE COLUMN--------------------------
                                  Key_Press_Row2: ;Readding from keypad
00008d ee00                          LDI R16 , 0xE0 ;low nible must be 0000  because did not work when it was F
00008e bb02                      	OUT PORTD , R16 ; PORTD = 0111----
00008f 9b82                      	SBIS PIND , 2
000090 c046                      	  RJMP Show_02  ; to show the nomber on portb/ 04 means column0 row2
                                 	
000091 ed00                      	LDI R16 , 0xD0 ;low nible must be 0000  
000092 bb02                      	OUT PORTD , R16 ; PORTD = 1011----
000093 9b82                      	SBIS PIND , 2
000094 c047                      	  RJMP Show_12  ; to show the nomber on portb/ 04 means column1 row2
                                 
000095 eb00                      	LDI R16 , 0xB0 ;low nible must be 0000  
000096 bb02                      	OUT PORTD , R16 ; PORTD = 1101----
000097 9b82                      	SBIS PIND , 2
000098 c048                      	  RJMP Show_22  ; to show the nomber on portb/ 04 means column2 row2
                                 
000099 e700                      	LDI R16 , 0x70 ;low nible must be 0000  
00009a bb02                      	OUT PORTD , R16 ; PORTD = 1110----
00009b 9b82                      	SBIS PIND , 2
00009c c049                      	  RJMP Show_32  ; to show the nomber on portb/ 04 means column3 row2
00009d cf92                       RJMP start ; Some times row dignose and MCU will come here, but it would'nt find the column _maybe becuse of the noise_
                                 					 ; and continiue the trail wich is no need, this line is for unpredicted event _the column have'nt seen_
                                 					 ;I did'nt use RJMP Key_Press_Row2 beacuse i tried and some times it lock in this loop, start is much better
                                 ;------------------------------------------ROW 3 DIGNOSED LET'S CLEAR THE COLUMN--------------------------
                                  Key_Press_Row3: ;Readding from keypad
00009e ee00                          LDI R16 , 0xE0 ;low nible must be 0000  because did not work when it was F
00009f bb02                      	OUT PORTD , R16 ; PORTD = 0111----
0000a0 9b83                      	SBIS PIND , 3
0000a1 c049                      	  RJMP Show_03  ; to show the nomber on portb/ 04 means column0 row3
                                 	
0000a2 ed00                      	LDI R16 , 0xD0 ;low nible must be 0000  
0000a3 bb02                      	OUT PORTD , R16 ; PORTD = 1011----
0000a4 9b83                      	SBIS PIND , 3
0000a5 c04a                      	  RJMP Show_13  ; to show the nomber on portb/ 04 means column0 row3
                                 
0000a6 eb00                      	LDI R16 , 0xB0 ;low nible must be 0000  
0000a7 bb02                      	OUT PORTD , R16 ; PORTD = 1101----
0000a8 9b83                      	SBIS PIND , 3
0000a9 c04b                      	  RJMP Show_23  ; to show the nomber on portb/ 04 means column0 row3
                                 
0000aa e700                      	LDI R16 , 0x70 ;low nible must be 0000  
0000ab bb02                      	OUT PORTD , R16 ; PORTD = 1110----
0000ac 9b83                      	SBIS PIND , 3
0000ad c04c                      	  RJMP Show_33  ; to show the nomber on portb/ 04 means column0 row3
0000ae cf81                       RJMP start ; Some times row dignose and MCU will come here, but it would'nt find the column _maybe becuse of the noise_
                                 					 ; and continiue the trail wich is no need, this line is for unpredicted event _the column have'nt seen_
                                 					 ;I did'nt use RJMP Key_Press_Row3 beacuse i tried and some times it lock in this loop, start is much better
                                  ;================================KEYPAD LOOKUP TABLE=========================================================
                                  ; After clearring both row and column, MCU pass here to show then number on PORTB, Then return to main _job_
                                  ;------------row 0--------------
                                  Show_00:
0000af e007                         LDI R16 , 0x07
0000b0 bb08                         OUT PORTB , R16
0000b1 940e 00ff                     CALL Arith_Function
                                 	;I have a number from keypad and must store it. Mention that you must store it one time
0000b3 9508                           RET
                                 
                                 Show_10:
0000b4 e008                         LDI R16 , 0x08
0000b5 bb08                         OUT PORTB , R16
0000b6 940e 00ff                     CALL Arith_Function
                                 		;I have a number from keypad and must store it. Mention that you must store it one time
0000b8 9508                           RET
                                 
                                 Show_20:
0000b9 e009                         LDI R16 , 0x09
0000ba bb08                         OUT PORTB , R16
0000bb 940e 00ff                     CALL Arith_Function
                                 		;I have a number from keypad and must store it. Mention that you must store it one time
0000bd 9508                           RET
                                 
                                 Show_30:
0000be ef0f                         LDI R16 , 0xFF
0000bf bb08                         OUT PORTB , R16
0000c0 940e 00ff                     CALL Arith_Function
                                 		;I have a number from keypad and must store it. Mention that you must store it one time
0000c2 9508                           RET
                                 ;-------------row 1---------------
                                 Show_01:
0000c3 e004                         LDI R16 , 0x04
0000c4 bb08                         OUT PORTB , R16
0000c5 940e 00ff                     CALL Arith_Function
                                 		;I have a number from keypad and must store it. Mention that you must store it one time
0000c7 9508                           RET
                                 
                                 Show_11:
0000c8 e005                         LDI R16 , 0x05
0000c9 bb08                         OUT PORTB , R16
0000ca 940e 00ff                     CALL Arith_Function
                                 		;I have a number from keypad and must store it. Mention that you must store it one time
0000cc 9508                           RET
                                 
                                 Show_21:
0000cd e006                         LDI R16 , 0x06
0000ce bb08                         OUT PORTB , R16
0000cf 940e 00ff                     CALL Arith_Function
                                 		;I have a number from keypad and must store it. Mention that you must store it one time
0000d1 9508                           RET
                                 
                                 Show_31:
0000d2 ef0e                         LDI R16 , 0xFE
0000d3 bb08                         OUT PORTB , R16
0000d4 940e 00ff                     CALL Arith_Function
                                 		;I have a number from keypad and must store it. Mention that you must store it one time
0000d6 9508                           RET
                                 ;-----------row 2----------------
                                 Show_02:
0000d7 e001                         LDI R16 , 0x01
0000d8 bb08                         OUT PORTB , R16
0000d9 940e 00ff                     CALL Arith_Function
                                 		;I have a number from keypad and must store it. Mention that you must store it one time
0000db 9508                           RET
                                 
                                 Show_12:
0000dc e002                         LDI R16 , 0x02
0000dd bb08                         OUT PORTB , R16
0000de 940e 00ff                     CALL Arith_Function
                                 		;I have a number from keypad and must store it. Mention that you must store it one time
0000e0 9508                           RET
                                 
                                 Show_22:
0000e1 e003                         LDI R16 , 0x03
0000e2 bb08                         OUT PORTB , R16
0000e3 940e 00ff                     CALL Arith_Function
                                 		;I have a number from keypad and must store it. Mention that you must store it one time
0000e5 9508                           RET
                                 
                                 Show_32:
0000e6 ef0d                         LDI R16 , 0xFD
0000e7 bb08                         OUT PORTB , R16
0000e8 940e 00ff                     CALL Arith_Function
                                 		;I have a number from keypad and must store it. Mention that you must store it one time
0000ea 9508                           RET
                                 ;-----------row 3---------------
                                 Show_03:
0000eb ee0f                         LDI R16 , 0xEF
0000ec bb08                         OUT PORTB , R16
0000ed 940e 00ff                     CALL Arith_Function
                                 		;I have a number from keypad and must store it. Mention that you must store it one time
0000ef 9508                           RET
                                 
                                 Show_13:
0000f0 e000                         LDI R16 , 0x00
0000f1 bb08                         OUT PORTB , R16
0000f2 940e 00ff                     CALL Arith_Function
                                 		;I have a number from keypad and must store it. Mention that you must store it one time
0000f4 9508                           RET
                                 
                                 Show_23:
0000f5 ed0f                         LDI R16 , 0xDF
0000f6 bb08                         OUT PORTB , R16
0000f7 940e 00ff                     CALL Arith_Function
                                 		;I have a number from keypad and must store it. Mention that you must store it one time
0000f9 9508                           RET
                                 
                                 Show_33:
0000fa ef0c                         LDI R16 , 0xFC
0000fb bb08                         OUT PORTB , R16
0000fc 940e 00ff                     CALL Arith_Function
                                 		;I have a number from keypad and must store it. Mention that you must store it one time
0000fe 9508                           RET
                                 ;=================ARITHMETIC FUNCTION===============
                                 Arith_Function:
0000ff ef1f                      		LDI KeyPad_counter_L , yekan_full   ;Full for keypad timmer (DISABLE HOLD TIME)  
000100 ef2f                      		LDI KeyPad_counter_H , dahgan_full
                                 		
000101 3d0f                      	CPI temp , 0xDF      ;'=' code for freq	        ;We have a number on R16. We should check it if it is '=' or not
000102 f049                      	BREQ frequency_is_pressed
000103 3f0c                      	   CPI temp , 0xFC   ;'+' code for duty cycle	;We have a number on R16. We should check it if it is '+' or not
000104 f0f1                      	   BREQ DutyCycle_is_pressd	
000105 9e24                      	         MUL R2 , ten  ; R20 =0x0A ;this would be wrong if the number in R2 and R3 more than 256 
                                 							; R2 must be clear for first number. EX:the number 300 contains R3 but we just mul R2,0x0A
000106 9488                      			 CLC ; clear cary
000107 0e00                      	         ADD R0 , temp
000108 1e13                      			 ADC R1 , clear ;add just with carry R19=0x00 becouse input num is 1 byte
000109 2c20                      			 MOV R2 , R0	;storring in R3,R2 for next number to be ready for multiply
00010a 2c31                      			 MOV R3 , R1			 			 
00010b 9508                      		RET ;i have a digit, go for next one or apply by pressing '=' or '+' on the next come
                                 			 		  
                                 	frequency_is_pressed:
                                 	; I have frequency value in R3,R2 so need to save them and prepare for devision => 1/f = T
                                 	; My main loop containe 40 commands, and each command (4MHz clk) wait for 1/4uSEC ==> each round in my main loop waits for 40*(1/4)uSEC => f=0.1MHz
                                 	; Now, For 100Hz => T is 0.01SEC(10mSEC) it means that I have to wait 1,000 rouns (1uSEC*1,000 = 1,000uSEC = 10mSEC)
                                 	; So, for make delay I count rouns, (rounds = 0.1MHz  /  input frequency) or (rounds = input T / 5 uSEC) --- 0.2MHz named loop_freq_k
                                 	; This is period. for duty cycle it must be dived. X% ON round and (100-X)% OFF rounds. see duty cycle algorithm for more information 	  
00010c 9230 0064                 	STS in_frequency_H_addr, R3 ;storring frequencu in SRAM    
00010e 9220 0065                 	STS in_frequency_L_addr, R2
                                 	;--Preparring values in registers for devision:
000110 2c42                      	  MOV R4 , R2		 ; R4 and R5 are the registers that contain Frequency values
000111 2c53                      	  MOV R5 , R3		 ; AND NEEDS FOR DEVIDER FUNCTION
000112 2e63                      	  MOV R6 , clear     ; this is 24 bits devide by 16 bits you know
                                 	   	  
000113 2f83                      	  MOV R24, clear  ;clearring R25 and R24 (quotient)
000114 2f93                      	  MOV R25, clear 
                                 	   
000115 eb50                      	  LDI R21 , loop_freq_0 ; R21 , R22 , R23 NEEDS FOR DEVIDER FUNCTION
000116 ea6d                      	  LDI R22 , loop_freq_1
000117 e071                      	  LDI R23 , loop_freq_2 
                                 	  ;--go for devision function:
                                       ;--R23 , R22 , R21 devide by R6 , R5 , R4 =result=> number of rounds wiche is input T ,(loop f/input f). put the result into R25 , R24 
000118 940e 0155                 	  CALL Dev_Start ;registers have their own valuse and go for function.
                                 
00011a 9390 0067                 	   STS tottal_round_H_addr, R25 ;now we have tottal number of rounds for makking T period of input frequency  
00011c 9380 0068                 	   STS tottal_round_L_addr, R24 ;I'm sure its going to osilate in than frequency let's go for setting duty cycle
                                 	   ;--befor next step we must clearring registers and initiolizing them for another begging.
00011e 2e23                      		MOV R2 , clear ;clearring R2 and R3 for begging time
00011f 2e33                      	    MOV R3 , clear 
000120 2f83                      		MOV R24 , clear ;clearring R2 and R3 for begging time
000121 2f93                      	    MOV R25 , clear
                                 		 	 
000122 c002                        RJMP Recheck     ;when a new frequency applied. it must fit with the duty cycle that exsist in DutyCycle_addr
                                 	  
                                 
                                     DutyCycle_is_pressd: ;Befor, READ LINE " frequency_is_pressed: "
                                 	;We have tottal rounds (T) and it must devide by duty cycle input.
                                 	;X% is for ON round and (100-X)% is for OFF rounds. 
                                 	      ;Here after the '+' pressed, a number [0:100]<255 fit in register R2 		 
000123 9220 0066                 		  STS DutyCycle_addr, R2  ;storring duty cycle in SRAM		  	 
                                 		  ;I have tottal rounds and want to seprate it in ON and OFF rounds
                                 		  ;----So prepare values in register for division. (tottal rounds*duty cycle)/100 _becouse duty cycle is in percent_
                                 		  ;--First 16 bit * 8 bit multiply 
                                   Recheck: ;RESET THE DUTY CYCLE BECOUSE FREQUENCY CHANGED
000125 9150 0068                 		  LDS R21,tottal_round_L_addr   ;R22, R21 * R4
000127 9160 0067                 		  LDS R22,tottal_round_H_addr   ;total rounds loaded for multiply DutyCycle
000129 2f73                      		  MOV R23 , clear
00012a 9040 0066                 		  LDS R4, DutyCycle_addr        ;Put duty cycle value from DutyCycle_addr to R4 for multiply
                                 		  
                                 		    ;--------this is a little compact: 
00012c 9d54                      			 MUL R21,R4				;    R23     R22      R21
00012d 2d50                      			 MOV R21,R0				; x                   R4 
00012e 2d01                      			 MOV temp,R1			;-----------------------
00012f 9d64                      			 MUL R22,R4				; =		     temp     R21     :R21= R4 * R21 and temp= R4 * R22 
000130 0e00                      			 ADD R0,temp			;    R1      R0
000131 1e13                      			 ADC R1,clear		    ;    R1      R0       R21 
000132 2d60                      			 MOV R22,R0				;    R23     R22      R21 = (total rounds x DutyCyle)
000133 2d71                      			 MOV R23,R1
                                 			 
                                 			 ;R23, R22, R21 are ready for dividding by 100DEC 0x64
                                 		  ;--This is 24 bit / 8 bit division.  
000134 2f83                      		  MOV R24, clear ;clearring R25 and R24 , 
000135 2f93                      	      MOV R25, clear
                                 		  
000136 e604                      		  LDI temp, 0x64 
000137 2e40                      		  MOV R4, temp   ;R23, R22, R21 are ready for dividding by 100DEC 0x64
000138 2e53                      		  MOV R5,clear   ;we don't need R5, you know
000139 2e63                      		  MOV R6,clear   ;we don't need R6, you know
                                 		  
00013a 940e 0155                 	 CALL Dev_Start	;For any usage of this function, make sure that you load the right number into R23, R22, R21/R6, R5, R4
                                 				  
00013c 9390 0069                 		 STS ON_round_H_addr,R25    ;We have (total rounds x DutyCyle)/100 in the registers R25,R24
00013e 9380 0070                 		 STS ON_round_L_addr,R24
000140 2ff9                      		 MOV R31,R25  ;ON ROUNDS IN REGISTERS R31 and R30 as you see in main
000141 2fe8                      		 MOV R30,R24	
000142 93f0 0069                 		   STS ON_round_H_addr, R31 ;now we have tottal number of rounds for makking T period of input frequency 
000144 93e0 0070                 		   STS ON_round_L_addr, R30
                                 
000146 91d0 0067                 		 LDS R29,tottal_round_H_addr ;R29 and R28 contain tottal rounds
000148 91c0 0068                 		 LDS R28,tottal_round_L_addr 
00014a 1bce                      		 SUB R28,R30    ;OFF ROUNDS = tottal rounds - ON rounds
00014b 0bdf                      		 SBC R29,R31     		   
00014c 93d0 0071                 		   STS OFF_round_H_addr, R29 ;now we have tottal number of rounds for makking T period of input frequency
00014e 93c0 0072                 		   STS OFF_round_L_addr, R28 	
000150 2e23                      	    MOV R2 , clear ;clearring R2 and R3 for begging time
000151 2e33                      	    MOV R3 , clear 
000152 2f83                      		MOV R24 , clear ;clearring R2 and R3 for begging time
000153 2f93                      	    MOV R25 , clear
                                 		  
000154 9508                          RET ;We have vlues in our registers. R28, R29, R30, R31
                                 
                                 ;==================================================================================================
                                 ;This is simple division algorithm. The error of this is +-1 in quotient and doen't check the signed of remain
                                 ;becous i just need the quotient. And the error is low for that.
                                 ;24 bits devision algorithm R23, R22, R21 / R6 , R5 , R4 AND R25 , R24 are the results (quotient)-------------
                                 Dev_Start:  
000155 1576                        CP R23,R6		;check if the big num devide by small num 
000156 f084                        BRBS 4,final  ;If negetive RET ;devide is imposible and opration finishned. HAVE R24 , R25
                                 ; BREQ level_0  ;it become wrong , i couldent find solution for this line. really no need actully.
000157 9601                          ADIW R25: R24, 1  ;increasing quotient and then subcribe true number
000158 1954                          SUB R21 , R4	  ;subcibbing...
000159 0965                          SBC R22 , R5
00015a 0976                          SBC R23 , R6
00015b cff9                      RJMP Dev_Start			;go for anouther check, if it is devidble do it 
                                   level_0:
00015c 1565                          CP R22,R5			;check if the big num devide by small num
00015d f04c                      	BRBS 4,final		;If negetive RET ;devide is imposible and opration finishned. HAVE R24 , R25
                                 ;	BREQ level_1		;it become wrong , i couldent find solution for this line. really no need actully.
00015e 9601                      	  ADIW R25: R24, 1  ;increasing quotient and then subcribe true number
00015f 1954                      	  SUB R21 , R4		;subcibbing...
000160 0965                      	  SBC R22 , R5
                                 ;	  SBC R23 , R6		;no need, clearly
000161 cffa                        RJMP level_0			;go for anouther check, if it is devidble do it
                                     level_1:
000162 1554                      	  CP R21,R4				 ;check if the big num devide by small num
000163 f01c                      	  BRBS 4,final			;If negetive RET ;devide is imposible and opration finishned. HAVE R24 , R25
                                 ;	  BREQ final			;it become wrong , i couldent find solution for this line. really no need actully.
000164 9601                      	    ADIW R25: R24, 1    ;increasing quotient and then subcribe true number
000165 1954                      		SUB R21 , R4		;subcibbing...
                                 ;		SBC R22 , R5        ;no need, clearly
                                 ;		SBC R23 , R6
000166 cffb                      	RJMP level_1			;go for anouther check, if it is devidble do it
                                   final:  ;the division is finished, we arrived at remain in R23,R22,R21 registers  
000167 9508                       RET
                                  


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega32" register use summary:
x  :   0 y  :   0 z  :   0 r0 :   5 r1 :   5 r2 :   8 r3 :   6 r4 :   9 
r5 :   5 r6 :   4 r7 :   0 r8 :   0 r9 :   0 r10:   0 r11:   0 r12:   0 
r13:   0 r14:   0 r15:   0 r16: 107 r17:   4 r18:   3 r19:  21 r20:   2 
r21:   9 r22:   8 r23:   6 r24:  10 r25:  10 r26:   0 r27:   0 r28:   8 
r29:   7 r30:   8 r31:   7 
Registers used: 21 out of 35 (60.0%)

"ATmega32" instruction use summary:
.lds  :   0 .sts  :   0 adc   :   2 add   :   2 adiw  :   3 and   :   0 
andi  :   0 asr   :   0 bclr  :   0 bld   :   0 brbc  :   0 brbs  :   3 
brcc  :   0 brcs  :   0 break :   0 breq  :   8 brge  :   0 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :   0 brlt  :   0 brmi  :   0 
brne  :   0 brpl  :   0 brsh  :   0 brtc  :   0 brts  :   0 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   0 call  :  22 cbi   :   0 cbr   :   0 
clc   :   1 clh   :   0 cli   :   0 cln   :   0 clr   :   0 cls   :   0 
clt   :   0 clv   :   0 clz   :   0 com   :   0 cp    :   3 cpc   :   0 
cpi   :   2 cpse  :   0 dec   :   9 eor   :   0 fmul  :   0 fmuls :   0 
fmulsu:   0 icall :   0 ijmp  :   0 in    :   0 inc   :   0 jmp   :   0 
ld    :   0 ldd   :   0 ldi   :  65 lds   :   9 lpm   :   0 lsl   :   0 
lsr   :   0 mov   :  29 movw  :   0 mul   :   3 muls  :   0 mulsu :   0 
neg   :   0 nop   :   4 or    :   0 ori   :   0 out   :  43 pop   :   0 
push  :   0 rcall :   0 ret   :  19 reti  :   0 rjmp  :  32 rol   :   0 
ror   :   0 sbc   :   4 sbci  :   0 sbi   :   0 sbic  :   0 sbis  :  20 
sbiw  :   0 sbr   :   0 sbrc  :   0 sbrs  :   0 sec   :   0 seh   :   0 
sei   :   0 sen   :   0 ser   :   0 ses   :   0 set   :   0 sev   :   0 
sez   :   0 sleep :   0 spm   :   0 st    :   0 std   :   0 sts   :  18 
sub   :   4 subi  :   0 swap  :   0 tst   :   6 wdr   :   0 
Instructions used: 23 out of 113 (20.4%)

"ATmega32" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x0002d0    720      0    720   32768   2.2%
[.dseg] 0x000060 0x000060      0      0      0    2048   0.0%
[.eseg] 0x000000 0x000000      0      0      0    1024   0.0%

Assembly complete, 0 errors, 0 warnings
